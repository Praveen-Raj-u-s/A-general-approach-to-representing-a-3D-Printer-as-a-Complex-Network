# -*- coding: utf-8 -*-
"""3D Printer as a Complex Network

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XSL_vx6ClXKpHG4FMdBB13S250F2mTmz
"""

import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define components as nodes with types
components = {
    "Extruder": "component",
    "Build Plate": "component",
    "X Motor": "motor",
    "Y Motor": "motor",
    "Z Motor": "motor",
    "Filament Feed Mechanism": "component",
    "Cooling Fans": "component",
    "Temperature Sensors": "sensor",
    "Motion Sensors": "sensor",
    "Control Board": "control",
    "X Motor Driver": "driver",
    "Y Motor Driver": "driver",
    "Z Motor Driver": "driver",
    "Extruder Heater": "component",
    "Power Supply": "power",
    "Filament Sensor": "sensor",
    "Endstop Switches": "sensor",
    "Bed Leveling Sensor": "sensor"
}

# Define interactions as edges with weights
interactions = [
    ("Extruder", "Extruder Heater", 2),
    ("Filament Feed Mechanism", "Extruder", 1),
    ("Temperature Sensors", "Extruder Heater", 1),
    ("Temperature Sensors", "Build Plate", 1),
    ("X Motor Driver", "X Motor", 2),
    ("Y Motor Driver", "Y Motor", 2),
    ("Z Motor Driver", "Z Motor", 2),
    ("Control Board", "X Motor Driver", 3),
    ("Control Board", "Y Motor Driver", 3),
    ("Control Board", "Z Motor Driver", 3),
    ("Control Board", "Filament Feed Mechanism", 2),
    ("Filament Sensor", "Filament Feed Mechanism", 1),
    ("Control Board", "Filament Sensor", 1),
    ("Control Board", "Cooling Fans", 1),
    ("Control Board", "Temperature Sensors", 1),
    ("Control Board", "Motion Sensors", 1),
    ("Control Board", "Endstop Switches", 1),
    ("Control Board", "Bed Leveling Sensor", 1),
    ("Power Supply", "Control Board", 4),
    ("Power Supply", "Extruder Heater", 3),
    ("Power Supply", "Cooling Fans", 3),
    ("Power Supply", "X Motor Driver", 3),
    ("Power Supply", "Y Motor Driver", 3),
    ("Power Supply", "Z Motor Driver", 3)
]

# Create a directed graph
G = nx.DiGraph()

# Add nodes to the graph
for component, comp_type in components.items():
    G.add_node(component, type=comp_type)

# Add edges to the graph
for interaction in interactions:
    G.add_edge(interaction[0], interaction[1], weight=interaction[2])

# Calculate network metrics
centrality = nx.degree_centrality(G)
clustering_coefficient = nx.clustering(G.to_undirected())

# Check for strong connectivity and calculate average path length if applicable
if nx.is_strongly_connected(G):
    average_path_length = nx.average_shortest_path_length(G)
else:
    # Work with the largest strongly connected component
    largest_scc = max(nx.strongly_connected_components(G), key=len)
    subgraph = G.subgraph(largest_scc)
    average_path_length = nx.average_shortest_path_length(subgraph)

# Print network metrics
print("Centrality:", centrality)
print("Clustering Coefficient:", clustering_coefficient)
print("Average Path Length:", average_path_length)

# Identify key components based on centrality
key_components = sorted(centrality.items(), key=lambda x: x[1], reverse=True)
print("Key Components:", key_components)

# Define colors for different types of nodes
colors = {
    "component": "lightblue",
    "motor": "lightgreen",
    "sensor": "lightcoral",
    "control": "orange",
    "driver": "lightpink",
    "power": "lightyellow"
}

# Get color for each node
node_colors = [colors[G.nodes[node]['type']] for node in G.nodes]

# Define edge widths and alpha based on weights
edge_widths = [max(1.5, G[u][v]['weight']) for u, v in G.edges]  # Minimum width increased to 1.5
edge_alphas = [max(0.4, G[u][v]['weight'] / 4.0) for u, v in G.edges]  # Minimum alpha increased to 0.4

# Define node sizes based on centrality
node_sizes = [3000 * centrality[node] + 1000 for node in G.nodes]

# Create a colormap for edges
cmap = cm.Blues
norm = plt.Normalize(vmin=min(edge_widths), vmax=max(edge_widths))

# Adjust layout to reduce node overlap
pos = nx.spring_layout(G, k=0.7, iterations=100, seed=42)  # Adjust k and iterations for better spacing

# Manual adjustments to specific nodes to reduce overlap
pos["Control Board"] = [0.5, 0.5]
pos["Power Supply"] = [0.7, 0.5]
pos['X Motor'] = [0.2, -0.70]
pos['Y Motor'] = [-0.65,0.5]
pos['Z Motor'] = [0.90, 0.9]
pos['Z Motor Driver'] = [1.0, 0.67]
pos['Control Board'] = [0.3,0.2]
pos['Power Supply'] = [0.35,0.6]
pos['Extruder Heater'] = [-0.72, -0.6]
pos['Filament Feed Mechanism'] = [-0.6, -0.15]
pos['Extruder'] = [-0.9, -0.35]
pos['Temperature Sensors'] = [0.2, -0.4]
pos['Bed Leveling Sensor'] = [0.9, 0.17]


plt.figure(figsize=(14, 10))
edges = nx.draw_networkx_edges(G, pos, arrowstyle='->', arrowsize=20, edge_color=edge_widths,
                               edge_cmap=cmap, width=edge_widths, alpha=edge_alphas, edge_vmin=0, edge_vmax=4, connectionstyle="arc3,rad=0.1")
nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=node_colors)
labels = nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')
edge_labels = nx.draw_networkx_edge_labels(G, pos, edge_labels=nx.get_edge_attributes(G, 'weight'))

plt.title('3D Printer as a Complex Network')
sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
sm.set_array([])
plt.colorbar(sm, label='Edge Weight')
plt.show()